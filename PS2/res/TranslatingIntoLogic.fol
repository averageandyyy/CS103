# Edit this file to write your answers to the "Translating Into Logic" problem.
#
# The first-order logic parser bundled with this assignment can understand
# logic formulas in a bunch of different formats. For example, all of the
# following are ways for expressing "∀x. (Cat(x) → ∃y. (Robot(y) ∧ ¬Loves(x, y)))":
#
#    forall x. (Cat(x) -> exists y. (Robot(y) /\ ~Loves(x, y)))
#
#    \forall x. (Cat(x) \to \exists y. (Robot(y) \land \lnot Loves(x, y)))
#
#    Ax. (Cat(x) implies Ey. (Robot(y) and not Loves(x, y)))
#
#    Ax. (Cat(x) =>
#       Ey. (Robot(y) && !Loves(x, y))
#    )
#
#    ∀x. (Cat(x) → ∃y. (Robot(y) ∧ ¬Loves(x, y)))
#
# You are *encouraged* to introduce linebreaks and whitespace into your
# answers to make them easier to read, especially for when you need to
# debug them!
#
# You can add comments into any formula you'd like. Any text after a hash
# mark (#) will be ignored, so formulas like these are fine:
#
#       forall x. (Cat(x) ->                      # for any cat...
#          exists y. (Robot(y) /\ !Loves(x, y))   # ... there's a robot
#       )                                         #     it doesn't love.
#
# To make things easier, we've copied the statements to translate into
# this file.

[Part (i)]  # "Robots do not love."
forall x. (Robot(x) -> forall y. !Loves(x, y))








[Part (ii)]  # "Each robot loves every cat, but no cat loves any person."
(forall r. (Robot(r) -> (forall c. (Cat(c) -> Loves(r, c))))) and
(forall c. (Cat(c) -> (forall p. (Person(p) -> !Loves(c, p)))))







[Part (iii)] # "Each cat only loves itself."
forall c. (Cat(c) -> ((forall x. (x != c -> !Loves(c, x))) and (Loves(c, c))))








[Part (iv)] # "if you pick a person, you’ll find that they love a cat if and only if they also love a robot."
forall p. (Person(p) -> ((exists c. (Cat(c) and Loves(p, c))) <-> (exists r. (Robot(r) and Loves(p, r)))))

# If you chose a person (every person), then you will find that there exists a cat they love if and only
# if there also exists a robot they love.







[Part (v)]   # "Each person loves exactly two cats and nothing else."

forall p.(Person(p) ->
          (exists c. exists d. (c != d and Cat(c) and Cat(d) and Loves(p, c) and Loves(p, d) and
           forall x. ((x != c and x != d) -> !Loves(p, x)))
          )
         )

# If you chose a person, then you will see that there exists 2 distinct cats c and d loved by p
# such that for all other entities, p does not love them.








[Part (vi)]  # "No two robots love exactly the same set of cats."
forall r.(Robot(r) -> (forall q. ((q != r and Robot(q)) -> exists c. (Cat(c) and (Loves(r, c) <-> !Loves(q, c))))))

# forall r. forall q. ((q != r and Robot(q) and Robot(r)) -> exists c. (Cat(c) and (Loves(r, c) <-> !Loves(q, c))))






